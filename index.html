<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Meeting Timer – VT (grupper & rammer)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800;900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#f8f7f5; --ink:#2b3432; --muted:#6c655e; --border:rgba(40,30,20,.12);
      --tl-green-1:#e9f3ec; --tl-green-2:#deefe4; --phase-intro:#87b9ff; --phase-review:#ffb766; --phase-outro:#87b9ff;
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%}
    body{font-family:"Nunito",ui-rounded,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink);background:var(--bg)}
    .wrap{max-width:min(860px,92vw);margin:40px auto;padding:0 12px}
    .card{background:#fff;border:1px solid var(--border);border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,.04);padding:18px}
    h1{margin:0 0 8px 0;font-size:22px}
    .timeline{position:relative;height:56px;border-radius:14px;overflow:visible;background:linear-gradient(#ffffff,#fdfcf9);border:1px solid var(--border)}
    .slot{position:absolute;top:0;height:100%;opacity:.22}
    #introSlot{background:var(--phase-intro)}
    #reviewSlot{background:var(--phase-review)}
    #outroSlot{background:var(--phase-outro)}
    .para-slot{position:absolute;top:0;height:100%;display:flex;align-items:flex-end;justify-content:center;gap:6px;padding-bottom:6px;border-right:1px solid var(--border);box-sizing:border-box;min-width:14px;background:var(--tl-green-1)}
    .para-slot.alt{background:var(--tl-green-2)}
    .para-slot>div{pointer-events:none;white-space:nowrap;overflow:hidden;line-height:1}
    .read-pin{position:absolute; left:50%; transform:translateX(-50%); bottom:-24px; width:16px; height:16px; background:url('img/read-icon.png') center/contain no-repeat; pointer-events:none; opacity:.95}
    .frame-pin{position:absolute; left:50%; transform:translateX(-50%); bottom:-24px; width:16px; height:16px; background:url('img/box-icon.png') center/contain no-repeat; pointer-events:none; opacity:.95}
    .elapsed{position:absolute;top:0;left:0;height:100%;background:rgba(46, 204, 113, .25);width:0%;transition:width .25s linear;z-index:2;pointer-events:none}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin:10px 0 14px}
    input,select{font:inherit;border:1px solid var(--border);background:#fff;padding:8px 10px;border-radius:10px}
    .btn{appearance:none;border:1px solid var(--border);background:#fff;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:700}
    .msg{margin-top:10px;font-size:16px;padding:10px 12px;background:#fffdf9;border:1px solid var(--border);border-radius:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>VT-tidslinje – grupper & rammer/les</h1>
      <div class="row">
        <label>Velg datafil: <select id="dataSel">
          <option value="/mnt/data/no-2025.json">no-2025.json (demo)</option>
          <option value="/mnt/data/vt_data_1.31.json">vt_data_1.31.json</option>
        </select></label>
        <button class="btn" id="reload">Last</button>
      </div>

      <div id="timeline" class="timeline" aria-label="Tidslinje for avsnitt">
        <div id="introSlot" class="slot"></div>
        <div id="reviewSlot" class="slot"></div>
        <div id="outroSlot" class="slot"></div>
        <div id="elapsed" class="elapsed"></div>
      </div>
      <div id="message" class="msg">—</div>
    </div>
  </div>

  <script>
  // Simplified slots (intro/review/outro) for demo
  function slots(){
    const total = Math.max(1, (window.perParagraph||[]).reduce((a,b)=>a+b,0) + 60 + 60);
    const intro = 60, review = 60, outro = 0;
    return { total, intro, review, outro, content: total - intro - review - outro };
  }

  // ==== State ====
  let paras=[], perParagraph=[], cumulative=[], totalParagraphs=0;
  let readSet=new Set();

  // ==== New helpers (groups/frames/reads) ====
  function parseGroupsString(str) {
    if (!str || typeof str !== 'string') return [];
    return str.split(',').map(s => s.trim()).flatMap(token => {
      const m = token.match(/^(\d+)(?:-(\d+))?$/);
      if (!m) return [];
      const a = Number(m[1]), b = m[2] ? Number(m[2]) : a;
      const group = [];
      for (let x = a; x <= b; x++) group.push(x);
      return [group];
    });
  }
  function parseAnnoFlexible(entry) {
    if (typeof entry === 'number') return { para: entry, order: null };
    const m = String(entry).toLowerCase().trim().match(/^(\d+)([a-z])?$/);
    if (!m) return null;
    return { para: Number(m[1]), order: m[2] ?? null };
  }
  function buildAnnotations(frames = [], reads = [], legacyReadParas = null) {
    const ordIdx = o => (o ? (o.charCodeAt(0) - 96) : null); // a->1
    const ann = new Map();
    const upsert = (p, key, o) => {
      if (!ann.has(p)) ann.set(p, { frame: null, read: null });
      ann.get(p)[key] = { present: true, ordIdx: ordIdx(o) };
    };
    if (Array.isArray(frames)) frames.map(parseAnnoFlexible).filter(Boolean).forEach(x => upsert(x.para, 'frame', x.order));
    if (Array.isArray(reads) && reads.length) reads.map(parseAnnoFlexible).filter(Boolean).forEach(x => upsert(x.para, 'read', x.order));
    else if (Array.isArray(legacyReadParas)) legacyReadParas.forEach(p => upsert(Number(p), 'read', null));
    return ann;
  }
  function rangeLabel(nums) {
    const sorted = [...new Set(nums)].sort((a,b)=>a-b);
    const contiguous = sorted.every((v,i)=> i===0 || v === sorted[i-1] + 1);
    if (sorted.length === 1) return `Avsnitt ${sorted[0]}`;
    return contiguous ? `Avsnittene ${sorted[0]}–${sorted[sorted.length-1]}` : `Avsnittene ${sorted.join('+')}`;
  }
  function orderExtrasForParas(paras, annotations) {
    let hasF=false, hasR=false, minF=null, minR=null;
    for (const p of paras) {
      const a = annotations.get(p); if (!a) continue;
      if (a.frame?.present){ hasF=true; if(a.frame.ordIdx!=null) minF = (minF==null? a.frame.ordIdx : Math.min(minF,a.frame.ordIdx)); }
      if (a.read?.present) { hasR=true; if(a.read.ordIdx!=null)  minR = (minR==null? a.read.ordIdx  : Math.min(minR, a.read.ordIdx)); }
    }
    if (!hasF && !hasR) return [];
    if (hasF && hasR) {
      if (minF!=null || minR!=null) return ((minF ?? 1e9) <= (minR ?? 1e9)) ? ['ramme','les-skriftsted'] : ['les-skriftsted','ramme'];
      return ['ramme','les-skriftsted'];
    }
    return hasF ? ['ramme'] : ['les-skriftsted'];
  }
  function groupColor(groupId){
    if (groupId === null) return null;
    const baseHue = 150; const l = 66 - (groupId % 3) * 8;
    return `hsl(${baseHue} 40% ${l}%)`;
  }

  // ==== Drawing ====
  function computeAllocation(){
    const S=slots();
    if(totalParagraphs<=0){perParagraph=[];cumulative=[];return;}
    // Here, perParagraph already equals words for demo; scale content to fit
    const raw = paras.map(p => Math.max(5, p.words || 0));
    const scale = S.content/((raw.reduce((a,b)=>a+b,0))||1);
    perParagraph = raw.map(x=>x*scale);
    cumulative=[]; let acc=S.intro; for(let i=0;i<totalParagraphs;i++){cumulative.push(acc); acc+=perParagraph[i];}
  }

  function drawTimeline(groupsString, annotations){
    const S=slots();
    const t=document.getElementById('timeline'); if(!t) return;
    Array.from(t.querySelectorAll('.para-slot')).forEach(n=>n.remove());
    const pct=v=> (v/S.total*100).toFixed(4)+'%';
    document.getElementById('introSlot').style.left='0%'; document.getElementById('introSlot').style.width=pct(S.intro);
    document.getElementById('outroSlot').style.right='0%'; document.getElementById('outroSlot').style.width=pct(S.outro);
    document.getElementById('reviewSlot').style.right=pct(S.outro); document.getElementById('reviewSlot').style.width=pct(S.review);
    if(totalParagraphs<=0){document.getElementById('elapsed').style.width='0%'; return;}

    const groups = parseGroupsString(groupsString);
    const paraToGroupId = new Map();
    groups.forEach((g,i)=> g.forEach(p => paraToGroupId.set(p, i)));

    for(let i=1;i<=totalParagraphs;i++){
      const leftP=(cumulative[i-1]/S.total)*100, widthP=(perParagraph[i-1]/S.total)*100;
      const slot=document.createElement('div'); slot.className='para-slot'+(i%2===0?' alt':''); slot.style.left=leftP+'%'; slot.style.width=widthP+'%';
      const lbl=document.createElement('div'); lbl.style.fontSize='12px'; lbl.textContent=String(i); slot.appendChild(lbl);

      // Group color
      const gid = paraToGroupId.has(i) ? paraToGroupId.get(i) : null;
      const col = groupColor(gid);
      if (col) slot.style.background = col;

      // Pins
      const a = annotations.get(i);
      if (a){
        const items = [];
        if (a.frame?.present) items.push({type:'frame', order: a.frame.ordIdx ?? 1});
        if (a.read?.present)  items.push({type:'read',  order: a.read.ordIdx  ?? 2});
        items.sort((x,y)=>x.order-y.order);
        const gap = 12; const baseShift = -((items.length-1)/2)*gap;
        items.forEach((it, idx) => {
          const pin = document.createElement('i');
          pin.className = it.type === 'frame' ? 'frame-pin' : 'read-pin';
          pin.style.left = `calc(50% + ${baseShift + idx*gap}px)`;
          slot.appendChild(pin);
        });
      }

      // Click -> message
      slot.addEventListener('click', ()=>{
        const g = groups.find(gr => gr.includes(i)) || [i];
        const extras = orderExtrasForParas(g, annotations);
        document.getElementById('message').textContent = extras.length ? `${rangeLabel(g)} + ${extras.join(' og ')}` : rangeLabel(g);
      });

      t.insertBefore(slot, document.getElementById('elapsed'));
    }
  }

  // ==== Load data & back-compat mapping ====
  async function loadData(url){
    const r=await fetch(url, {cache:'no-store'}); if(!r.ok) throw new Error('Kunne ikke laste '+url);
    const json=await r.json();
    const first = json.items?.[0]; if (!first) throw new Error('Ingen items');
    // Back-compat: if only para_lengths provided, copy to words; derive readParas if reads present
    json.items.forEach(it=>{
      if (Array.isArray(it.para_lengths) && !Array.isArray(it.words)) it.words = it.para_lengths.slice();
      if (!Array.isArray(it.readParas) && Array.isArray(it.reads)) {
        const nums = it.reads.map(e=>{ const m=String(e).match(/^(\d+)/); return m? Number(m[1]) : null; }).filter(n=>Number.isFinite(n));
        if (nums.length) it.readParas = nums;
      }
    });
    return json;
  }

  async function init(){
    const sel = document.getElementById('dataSel');
    document.getElementById('reload').addEventListener('click', bootstrap);
    await bootstrap();
    async function bootstrap(){
      const url = sel.value;
      const data = await loadData(url);
      const it = data.items[0];
      const groupsString = typeof it.groups === 'string' ? it.groups : "";
      const frames = Array.isArray(it.frames) ? it.frames : [];
      const reads = Array.isArray(it.reads) ? it.reads : [];
      const legacyRP = Array.isArray(it.readParas) ? it.readParas : (Array.isArray(it.read_paras) ? it.read_paras : null);

      totalParagraphs = (Array.isArray(it.words)?it.words.length:0);
      paras = (it.words||[]).map((w,i)=>({num:i+1,words:w|0}));
      readSet = new Set(legacyRP || []);

      // Compute and draw
      computeAllocation();
      const annotations = buildAnnotations(frames, reads, legacyRP);
      drawTimeline(groupsString, annotations);

      // Set initial message
      const g = parseGroupsString(groupsString)[0] || [1];
      const extras = orderExtrasForParas(g, annotations);
      document.getElementById('message').textContent = extras.length ? `${rangeLabel(g)} + ${extras.join(' og ')}` : rangeLabel(g);
    }
  }
  window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
